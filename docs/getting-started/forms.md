---
layout: wmt/docs
title:  Forms
---

# Forms

Concord flows can provide simple UIs using forms. Forms are described
declaratively in [project files](processes.html) and (optionally) can
contain custom HTML/CSS/JS/etc resources
(["custom forms"](#custom-forms)).

## Form Syntax

### Declaring a new form

Forms are declared at in the `forms` section of a `.concord.yml`
document:

```yaml
forms:
  myForm:
  - ...
```

The name of a form (in this example it's `myForm`) can be used to
[call a form](#calling-a-form) from a process. Also, it will be used
as a name of an object which will store the values of the fields.

### Form fields

Forms must contain one or more fields:

```yaml
forms:
  myForm:
  - fullName: { label: "Name", type: "string", pattern: ".* .*" }
  - age: { label: "Age", type: "int", min: 21, max: 100 }
  - favouriteColour: { label: "Favourite colour", type: "string", allow: ["gray", "grey"] }
  - languages: { label: "Preferred languages", type: "string+", allow: "${locale.languages()}" }
  - password: {label: "Password", type: "string", inputType: "password"}
```

Field declaration consists of the name (`myField`), the type
(`string`) and additional options.

The name of a field will be used to store a field's value in the
form's results. E.g. if the form's name is `myForm` and the field's
name is `myField`, then the value of the field will be stored in
`myForm.myField` variable.

Common options:
- `label`: the field's label, usually human-readable;
- `value`: default value [expression](#expressions), evaluated when
the form is called;
- `allow`: allowed value(s). Can be a YAML literal, array, object or an
[expression](#expressions).

Supported types of fields and their options:
- `string`: a string value
  - `pattern`: (optional) a regular expression to check the value.
  - `inputType`: (optional) specifies the type of html <input>
  element to display.
- `int`: an integer value
  - `min`, `max`: (optional) value bounds.
- `decimal`: a decimal value
  - `min`, `max`: (optional) value bounds.
  
Cardinality of the field can be specified by adding a cardinality
quantifier to the type:
- a single non-optional value: `string`;
- optional value: `string?`;
- one or more values: `string+`;
- zero or more values: `string*`.

Additional field types will be added in the next versions.

### Calling a form

To call a form from a process, use `form` command:

```yaml
main:
  - form: myForm
  - log: "Hello, ${myForm.myField}"
```

Forms will be pre-populated with values if the current context
contains a map object, stored under the form's name. E.g. if the
context has a map object

```json
{
  "myForm": {
    "myField": "my string value"
  }
}
```

then the form's `myField` will be populated with `my string value`.

The `form` command accepts additional options:
```yaml
main:
  - form: myForm
    yield: true
    values:
      myField: "a different value"
      additionalData:
        nestedField:
          aValue: 123
```

Supported options:
- `yield`: a boolean value. If `true`, the UI wizard will stop after
this form and the rest of the process will continue in "background".
Supported only for custom (with branding) forms;
- `values`: additional values, to override default form values or to
provide additional data.

## Custom forms

Look and feel of a form can be changed by providing form's own HTML,
CSS, JavaScript and other resources.

For example, if we have a `.concord.yml` file with a single form:
```yaml
flows:
  main:
  - form: myForm
  - log: "Hello, ${myForm.name}"
  
forms:
  myForm:
  - name: {type: "string"}
```

then we can provide a custom HTML for this form by placing it into
`forms/myForm/index.html` file:
```
forms/
  myForm/
    index.html
    
.concord.yml
```

When the form is activated, the server will redirect a user to the
`index.html` file.

Here's an example of how a `index.html` file could look like:
```html
<!doctype html>
<html lang="en">
<head>
    <title>My Form</title>
    <script src="data.js"></script> <!-- (1) -->
</head>
<body>

<h1>My Form</h1>

<script type="text/javascript">
    function handleSubmit(form) {
       form.action = data.submitUrl; // (2)
    }
</script>

<form method="post" onsubmit="handleSubmit(this)">
    <label>Name:</label>
    <input name="name"/>  <!-- (3) -->
    
    <button>Submit</button>
</form>

</body>
</html>
```

Let's take a closer look:
1. `data.js` is referenced - a JavaScript file which is generated by
the server when the form is opened. See the
[Accessing the data](#accessing-the-data) section for more details;
2. `submitUrl`, a value provided in `data.js`, used as a submit URL
of the form. For every instance of a form, the server provides a
unique URL;
3. a HTML input field added with the name same as the name of
`myForm` field.

Forms can use any external JavaScript library or a CSS resource. The
only mandatory part is to use provided `submitUrl` value.

### Accessing the data

When a custom form is opened, the server generates a `data.js` file.
It contains values of the fields, validation error and additional
metadata:
```javascript
data = {
  "success" : false,
  "processFailed" : false,
  "submitUrl" : "/api/service/custom_form/f5c0ab7c-72d8-42ee-b02e-26baea56f686/cc0beb01-b42c-4991-ae6c-180de2b672e5/continue",
  "definitions" : {
    "name": {
        "type": "string"
    }
  },
  "values" : {
    "name": "Concord"
  },
  "errors" : {
    "name": "Required value"
  }
};
```

The file defines a JavaScript object with the following fields:
- `success` - `false` if a form submit failed;
- `processFailed` - `true` if a process execution failed outside of
a form;
- `submitUrl` - automatically generated URL which should be used to
submit new form values and resume the process;
- `definitions` - form field definitions. Each key represents a
field:
  - `type` - type of the field;
  - `label` - optional label, set in the form definition;
  - `cardinality` - required cardinality of the field's value;
  - `allow` - allowed value(s) of the field.
- `values` - current values of the form fields;
- `errors` - validation error messages.

### Shared resources

Custom forms can have shared resources (e.g. common scripts or CSS
files). Those resources should be put into `forms/shared` directory
of a process:
```
forms/
  myForm/
    index.html
  myOtherForm/
    image.png
    index.html
  shared/
    logo.png
    common.js
    common.css
```

Shared resources can be referenced by forms using relative path:
```html
<head>    
    <script src="../shared/common.js"></script>
</head>
```

### Examples

The Concord repository contains a couple of examples on how to use
custom and regular forms:
- [single form](https://gecgithub01.walmart.com/devtools/concord/tree/master/examples/forms)
- [custom form](https://gecgithub01.walmart.com/devtools/concord/tree/master/examples/forms_branding)
- [custom form with dynamic fields](https://gecgithub01.walmart.com/devtools/concord/tree/master/examples/dynamic_forms)

## Accessing forms

Forms can be accessed by a user in two different ways:
- though [the "portal" URL](../api/process.html#from-a-browser);
- by clicking on the "wizard" button on the Console's process
status page.

In both cases, users will be redirected from form to form until the
process finishes, an error occurs or until a form with `yield: true`
is reached.